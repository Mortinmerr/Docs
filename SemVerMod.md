# Версионирование ПО во встраиваемых системах

## Введение
Версионирование — это процесс управления изменениями в программном обеспечении. Для встраиваемых систем, где ПО плотно связано с аппаратной частью, важно поддерживать чёткую систему версий, чтобы избежать несовместимости и обеспечить стабильность.

## Выбранный нами подход к версионированию.

### 1. Дополненное семантическое версионирование (SemVer)
Для оформления версионирования наших документов за основу был взят стандарт [SemVer 2.0.0](https://semver.org/lang/ru/), где версия разбивается по уровню изменений и разделяется точками.

Структура:
```
major.minor.patch
```
- **major version (`X.0.0`)** — несовместимые изменения API.
- **minor version (`0.X.0`)** — добавление функционала, с сохранением совместимости API.
- **patch (`0.0.X`)**         — исправление обнаруженной ошибки, без изменения API.

Под API понимается (от англ. Application Programming Interface) — набор правил и описаний, определяющий, как одна программа может взаимодействовать с другой. Проще говоря, это документированное «меню команд», через которое одна система обращается к другой.

При **major** обновлении, номера **minor** и **patch** сбрасываются в 0.

При **minor** обновлении, номер **patch** сбрасывается в 0.

При **patch** обновлении, меняется только номер **patch**.

Пример версий:
```
- `v0.1.0` — первая минимально-функциональная версия.
- `v0.1.1` — фикс мелкого бага.
- `v0.2.1` — добавление нового функционала без изменения API.
- `v1.0.0` — обновление API.
- `v1.1.0` — добавлена новая функция, но API не изменился.
```

### 2. Ревизии аппаратных изменений
При изменениях в схемотехнике или трассировке, вводятся аппаратные **ревизии (`rA`, `rB` и т. д.)**, где "r" означает "revision", чтобы отслеживать совместимость ПО с платформами разных ревизий.
Аппаратных ревизий может быть несколько в одной версии ПО, если код поддерживает прошлые ревизии платформы и новую, (например, через конфигурационный файл или автоматизированные инструменты обратной совместимости).

Изначально, код пишется под какую-то существующую ревизию платформы.
Если она одна и других не планируется до того момента, пока не будет обнаружена 
ошибка в текущей платформе, то эта ревизия считается автоматически "rA", и ее 
указывать явно, прописывая в версии не обязательно.

Пример связи версий ПО и аппаратных ревизий:
```
v1.2.3     - для версии ПО, написанного под текущую A ревизию.
v1.2.3.rB  - для ПО, поддерживающего только B ревизию
v1.2.3.rAB - для ПО, поддерживающего A и B ревизии
v1.2.3.rAC - для ПО, поддерживающего A и С ревизии, но не поддерживающего В ревизию.
```

Подобный подход может помочь в автоматическом отслеживании совместимостей версий
различных составных частей\библиотек ПО.

Для автоматизации проверки совместимости и обновлений подключаемой библиотеки,
используйте "**#define**"-ы в головном **"\*.h"** файле.

Просто скопируйте предложенный ниже шаблон. Через поиск с автозаменой, замените
LIBNAME_ на название вашей библиотеки, например MYCOOLLIB_ и Пропишите значения
всех дефайнов: LIBNAME_VER_MAJOR, LIBNAME_VER_MINOR, LIBNAME_VER_PATCH,
LIBNAME_VER_DOC, LIBNAME_VER_REV_STR, LIBNAME_VER_REV_MASK.

Шаблон:

```
//~~~~~~~~~~~~~~~~~~~~  just like in the header template  ~~~~~~~~~~~~~~~~~~~~~~
 * @version major.minor.patch.rev
 * @brief   -
 * @details -
 * @todo    -
 ******************************************************************************/

#ifndef FILE_H
#define FILE_H

/* ===================== How to check version ======================
 *
 * #include "LibName.h"
 *
 * // --- Strong verification (exact match) ---
 * #if !LIBNAME_VERSION_CHECK(1, 0, 4, (LIBNAME_REV_A | LIBNAME_REV_B))
 * #   error "LibName version mismatch: need exactly v1.0.4 with revisions A&B"
 * #endif
 *
 * // --- Flexible verification (range checks) ---
 * #if (LIBNAME_VER_MAJOR != NUM)
 * #  error "Incompatible Major Version LibName Library!"
 * #endif
 * #if (LIBNAME_VER_MINOR < NUM)
 * #  error "Incompatible Minor Version LibName Library!"
 * #endif
 * #if (LIBNAME_VER_PATCH < NUM)
 * #  error "Incompatible Patch Version LibName Library!"
 * #endif
 * #if !LIBNAME_SUPPORTS(LIBNAME_REV_A)
 * #   error "Need revision A!"
 * #endif
 * #if !LIBNAME_SUPPORTS(LIBNAME_REV_A | LIBNAME_REV_B)
 * #   error "Need revisions A and B!"
 * #endif
 *
 * ================================================================ */

// ---------------- Version ----------------
#define LIBNAME_VER_MAJOR   0
#define LIBNAME_VER_MINOR   2
#define LIBNAME_VER_PATCH   0
#define LIBNAME_VER_DOC     0
#define LIBNAME_VER_REV_STR "A"

// ---------------- Revision bits ----------------
#define LIBNAME_REV_A   (1u << 0)
#define LIBNAME_REV_B   (1u << 1)
#define LIBNAME_REV_C   (1u << 2)
#define LIBNAME_REV_D   (1u << 3)
// ...

#define LIBNAME_VER_REV_MASK  (LIBNAME_REV_A)                   // Only A
// #define LIBNAME_VER_REV_MASK (LIBNAME_REV_B)                 // Only B
// #define LIBNAME_VER_REV_MASK (LIBNAME_REV_A | LIBNAME_REV_B) // A & B
// ...

// ---------------- Helpers ----------------
#define LIBNAME_SUPPORTS(rev_mask) \
    (((LIBNAME_VER_REV_MASK) & (rev_mask)) == (rev_mask))

#define LIBNAME_VERSION_CHECK(MAJ, MIN, PATCH, REV_MASK) \
    ( (LIBNAME_VER_MAJOR == (MAJ))   && \
      (LIBNAME_VER_MINOR == (MIN))   && \
      (LIBNAME_VER_PATCH == (PATCH)) && \
     ((LIBNAME_VER_REV_MASK & (REV_MASK)) == (REV_MASK)) )
 
```

### 3. Версионирование нефункциональных изменений
В случае, если в коде обновилось что-то, что не влияет на его работу, то добавляется
еще одна цифра к концу версии, через символ ">". Например, это может быть изменение форматирования кода, или правка\дополнение комментариев\документации.

При переходе на новую **major**, **minor**, **patch** или **rev** версию, номер версии документации обнуляется, т.к. смена версии подразумевает изменение кода и правку документации.

Добавление отметки о нефункциональных изменениях носит рекомендательный характер. 
Можете этого и не делать, но тогда может случиться ситуация, при которой вам будет сложно 
отличить друг от друга две кодовые базы, после внесения совсем небольшой правки в документацию.
При своевременном внесении изменений в версионирование, открыв файл истории версий библиотеки\проекта, или головной исходный файл, вы сразу сможете понять, #ая версия библиотеки самая свежая по части исправления документации или форматирования.

***Пример всех вышеописанных правил версионирования:***
```
- v1.0.0      — первая стабильная версия (.rA можно не писать).
- v1.1.0      — добавлена новая функция, но API остался совменстимым.
- v1.1.0.rB   — добавлена поддержка обновленной трассировки\схемотехники, без совместимости с исходной.
- v1.1.0.rB>1 — исправлено форматирование, после ревью.
- v1.1.0.rB>2 — дополнена документация.
- v1.1.1.rB   — исправлен мелкий баг.
- v1.1.1.rB>1 — комментарии дополнены тегами авто-документации.
- v2.0.0      — несовместимое обновление API, но без поддержки ревизии B.
- v2.0.0.rB  — добавлена поддержка ревизии B, без поддержки ревизии А.
- v2.0.0.rC  — поддержка ревизии C, без А и В, с сохранением совместимости API.
- v2.0.0.rAB — Поддержка ревизии A и B, с сохранением совместимости API.
  или
- v3.0.0.rAB — Поддержка ревизии A и B, с несовместимым обновлением API.
```

### 4. Документирование версий библиотек
Для отслеживания изменений, внесенных в очередной версии библиотеки, рекомендуется, в корневом каталоге библиотеки, завести файл Releases Notes "LibName_RN.md".
В нем ведется документация о версиях библиотеки в формате markdown . 

Пример:
```
* Version 0.1.2:
  * This version history file has been created.
  
  * Added functions for packing data back into a 32-bit word after
    receiving it from the parser. May be useful for
    working with ready-made word templates:
    - /**
       * @brief      Packing Telemetry data to the register word
       *
       * @param[in]  Desc_p  Pointer to Register Description
       *
       * @return     Raw Packaged register data
       */
     static inline uint32_t AXICptr_Telemetry_Pack
                                          (const AXICptrReg_Telemetry_t* Desc_p)
    - /**
       * @brief      Packing Telemetry data to the register word
       *
       * @param[in]  Desc_p  The register description pointer
       *
       * @return     Raw Packaged register data
       */
     static inline uint32_t AXIClGe_Telemetry_Pack
                                          (const AXIClGeReg_Telemetry_t* Desc_p)

* Version 0.1.1>1:
  * Refresh Number Of Exclude Bins in code auto-documentation comments.
    - Before: Right Exclude Bits = 6, Left * = 5
    - After:  Right Exclude Bits = 5, Left * = 6

AXIDevices Library Releases Notes and Versions.
Most recent version described in this file is the current version of the lib.

* Version 0.1.0:
  * First version of library.
  
```


## Версионирование проектов
Обычно, проект имеет свои головные исходные файлы, с описанием алгоритма работы "верхнего уровня",
который уже использует библиотеки, реализующие задачи на "уровнях ниже".

Допустим, у вас есть библиотеки **XLib Ver.1.2.3**, **YLib Ver.1.0.2**,
**ZLib Ver.0.2.5**, которые эксплуатируются проектом **PrjName**.

### Как меняется номер версии проекта:  
Если было **major**, **minor**, **patch** обновление на уровне алгоритма проекта,
не затрагивая подключенные библиотеки, то версионирование проекта ведется 
по тем же правилам, что и у библиотек. 
  
Обновление включенных в проект библиотек:  

  1.  Если в библиотеках **XLib** и **YLib** произошло **patch** обновление:  
        
      Независимо от количества обновлений в файлах включенных в проект, версия проекта увеличивается на единицу только один раз - в момент релиза проекта.  
      Например:
      * Было:  
        * PrjName Ver.2.1.5,  XLib Ver.3.2.1,  XLib Ver.1.2.3
      * Стало
        * PrjName Ver.2.1.6,  XLib Ver.3.2.2,  XLib Ver.1.2.5

  2. Если, в библиотеках X и Y произошло ***minor*** обновление.  
    
      То же самое что и patch, только ***minor***.

  3. Если, в библиотеках X и Y произошло ***major** обновление.  
        
      Т.к. ***major*** версия - это самое крупное обновление, которое говорит
      о несовместимости на уровне внешнего API, стоит ввести правило:
        * Если ***major версия*** библиотек сменилась, но ***не*** вызвала изменения 
          внешнего API проекта, то у проекта увеличивается ***minor*** версия.
        * Если ***major версия*** библиотек сменилась, и ***вызвала*** изменения 
          внешнего API проекта, то у проекта увеличивается ***major*** версия.  

  4. Ревизия проекта не меняетсся до тех пор, пока все составные части не будут поддерживать обновленную аппаратную резизию.  
        
      * Когда ***одна из библиотек*** начала поддерживать новую ревизию хардвара,
      а ***остальные***, связанные с этим же хардваром ***нет***, то у проекта увеличивается ***minor*** версия, 
      * Если ***все библиотеки*** связанные с обновленным хардваром\узлом
        начали поддерживать новую ревизию хардвара, то у проекта увеличивается 
        ***.revision*** версия, Т.к. по сути, проект теперь поддерживает другую ревизию полностью.
      * Если два верхних пункта вызвали изменение внешнего API, то следует менять
         и ***major версию***.

### Документирование версий проекта

Для отслеживания версий проекта, необходимо в корневом каталоге библиотеки завести файл releases notes "PrjName_RN.md" в котором будет вестись документация в формате markdown. Об этом файле обязательно нужно упомянуть в README.md.

Например:
```
PrjName Project Releases Notes and Versions.
Most recent version described in this file is the current version of the project.

* Version 2.2.1.rAB>1:
  * DOC: updated README (connection diagram, HW rev selection), added doxygen comments.
  * Code: no changes.

* Version 2.2.1.rAB:
  * HW: full support for rev A and rev B across all related libraries (end-to-end).
  * Functional code unchanged vs 2.2.1 → SemVer part stays the same, suffix changed to `.rAB`.
  * Dependencies:
    - XLib v3.2.2.rAB
    - YLib v1.3.0.rB   (minor update added rev B handling)
    - ZLib v0.2.5

* Version 2.2.1:
  * MINOR: partial support for new HW rev B introduced in some libraries (project not end-to-end compatible yet).
  * Notes:
    - HW rev B is not fully supported by all dependent libs; project remains A-primary.
  * Dependencies:
    - XLib v3.2.2.rAB (added rev B pin-map)
    - YLib v1.2.5 (no rev B yet)
    - ZLib v0.2.5 (no change)

* Version 2.2.0:
  * MINOR: new functionality without breaking public API.
  * Added features:
    - Streaming telemetry mode.
    - CLI command `stats dump`.
  * API additions (examples):
    - /**
       * @brief      Enable streaming telemetry
       * @param[in]  enable  0/1
       */
      void Prj_Streaming_Enable (int enable);
    - /**
       * @brief      Dump runtime statistics to console
       */
      void Prj_Stats_Dump (void);
  * Dependencies: unchanged (X 3.2.2.rA, Y 1.2.5, Z 0.2.5)    

* Version 2.1.5:
  * Base release of the project (HW rev A is implicit, suffix `.rA` may be omitted).
  * Public API: stable.
  * Dependencies:
    - XLib v3.2.1.rA
    - YLib v1.2.3
    - ZLib v0.2.5
```
### Возможные вопросы:
- Что я должен делать с версиями в 0.y.z на начальной стадии разработки?
   - Самое простое — начать разработку с 0.1.0 и затем увеличивать минорную версию для каждого последующего релиза.

- Как я узнаю, когда пора делать релиз 1.0.0?
  - Если ваше ПО используется на продакшене, оно, вероятно, уже должно быть версии 1.0.0. Если у вас стабильный API, от которого зависят пользователи, версия должна быть 1.0.0. Если вы беспокоитесь за обратную совместимость, вероятно, версия вашего ПО уже 1.0.0.

- Что мне делать, если я случайно зарелизил обратно несовместимые изменения как минорную версию?
  - Как только вы поняли, что нарушили спецификации Семантического Версионирования, исправьте проблему и выпустите новую минорную версию, которая исправляет проблему и восстанавливает обратную совместимость. Даже в таких обстоятельствах неприемлемо модифицировать уже выпущенные релизы. Если это необходимо, укажите в документации о нарушении обратной совместимости, версионирования и проинформируйте ваших пользователей, чтобы они знали о нарушении порядка версий.


- Что делать с устаревшей функциональностью?
  - Объявление функциональности устаревшей — это обычное дело в ходе разработки и часто необходимо для продвижения вперёд. Когда вы объявляете устаревшим часть публичного API, вы должны сделать две вещи: (1) обновить вашу документацию, чтобы дать пользователям узнать об этом изменении; (2) выпустить новый релиз с увеличением минорной версии. Прежде чем вы полностью удалите устаревшую функциональность в релизе с увеличением главной версии, должен быть как минимум один минорный релиз, содержащий объявление функциональности устаревшей, чтобы пользователи могли плавно перейти на новый API.

### Выводы по разделу: 
Использование версионирования по данной статье значительно облегчит отслеживание изменений в коде во избежание несовместимости и обеспечения стабильности для вас и для ваших коллег.


## Рекомендации по версионированию при разработке под SoC

### 1. Раздельное ведение репозиториев и версий для PS и PL
При разработке под SoC (например, Zynq) программная (PS) и аппаратная (PL) части развиваются независимо, поэтому имеет смысл вести **разные репозитории** и версии для них.

- **Репозиторий PS (процессорная часть):**
  - Код baremetal или OS на C/C++.
  - Блок-дизайн (Vivado `.xsa`, `.tcl`, `.bd`).
  - Файлы для FSBL, PMU и других компонентов.
  - Milestones и релизы ориентированы на стабильность PS и его API для взаимодействия с PL.

- **Репозиторий PL (программируемая логика):**
  - Код на VHDL/Verilog.
  - XDC-констрейнты, тестбенчи.
  - Файлы для интеграции с PS (`.hwh`, `.xsa`).
  - Milestones и релизы ориентированы на изменения в логике PL и совместимость с PS.

### 2. Связь между версиями PS и PL
Чтобы отслеживать совместимость, для синхронизации в репозитории git используются milestone'ы и issue.
Issue — конкретная задача/баг/идея.
Milestone — набор задач, объединённых общей целью (обычно релиз или этап разработки).

Пример процесса:
1. Ты подготавливаешь и делаешь релиз репозитория PS части **(например PS v1.2.0).**
2. Открываешь репозиторий содержащий в себе PL часть и создаешь в нём issue с примерным текстом: 
*«Адаптировать PL под PS v1.2.0»* и прикладываешь ссылку на релиз из п.1.
3. PL-разработчики ознакамливаются с релизом PS части и обновляют свои интерфейсы или логику в PL
части так, чтобы она была совместима с релизом PS части. 
4. PL-разработчики создают свой релиз со своей версией кода **например pl-v1.2.0** , добавляя в документации информацию о
совместимости этого релиза с релизом **PS v1.2.0**, прилагая ссылку на issue и ссылку ра релиз PS части.
4. если в репозитории PL используются milestone, то в milestone'ах надо зафиксировать совместимость новой версии PL с PS v1.2.0:
   ```
   - PS v1.2.0 совместим с PL v1.2.0
   ```

### Вывод по разделу:
Разделение версий PS и PL, использование SemVer и ведение milestone'ов позволяет:</br>
* Избежать путаницы между кодом PS и PL.</br>
* Гибко обновлять компоненты, не ломая совместимость.</br>
* Контролировать переход на новые версии, отслеживать изменения и совместимость версий.

Следование этим принципам упростит поддержку проекта и интеграцию новых функций.

</br>
